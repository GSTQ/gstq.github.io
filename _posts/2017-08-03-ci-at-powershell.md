---
layout: post
title: CI на Powershell
tags: Gitlab .Net CI Poweshell
comments: true
---
Вот уже месяца три, как мы пилим новый функционал в наших проектах в микросервисной архитектуре. И вот, наконец-то дошли руки сделать автоматический деплой сервисов для тестирования приложений. Однако, как всегда, не наступив не некоторое количество грабель сделать ничего не получилось.

<!--more-->
Так как основная технология разработки приложений - .Net, то было принято решение делать сервисы тоже на .Net. В качестве сервера был выбран фреймворк Nancy. В интернете пишут, что он является аналогом Sinatra на Ruby. В целом фреймворк мне понравился - он достаточно несложный, писать на нем быстро, имеет понятный роутинг, есть мощные инструменты для тестирования, сам сервер собирается в исполняемый файл. 
  
Код хранится в Gitlab, поэтому и сборка тоже ведется в нем. У него достаточно продвинутая CI, которая позволяет подключать неограниченное число ранеров. Ранер написан на Go и запускается как служба на Windows машине от имени пользователя. В качестве среды исполнения можно выбрать докер, kubernetes или shell. Но, так как у нас простые Windows приложения - то простого shell нам достаточно.

Казалось бы какие могут возникнуть трудности в деплое сервера, который представляет собой один exe-файл? Построй приложение в релиз-конфигурации, скопируй и положи куда нужно конфигурационные файлы, запусти нужный процесс. 

Для запуска сервера необходимо получить свободный открытый порт из диапазона и положить его в конфигурационный файл. Для этого написан простой скрипт на powershell:
{% highlight powershell %}
$config = [xml](Get-Content $configPath)
$allPorts = (40000..49999) 
$usedPorts = netstat -ant | grep  -oh ":4[0-9][0-9][0-9][0-9]" | cut -c 2-
$firstFreePort = 1
foreach ($port in $allPorts) {
  if ($usedPorts -notcontains $port)
  {
    $firstFreePort = $port
    break
  }
}

$config.serverInstance.instance.port = "$firstFreePort"
$config.Save($configPath)
{% endhighlight %} 

Однако с запуском и остановкой сервера возникли проблемы. 

Если запускать новый процесс в powershell, который был запущен в службе - то процесс будет запущен от того же пользователя, что и служба как ожидается:
{% highlight powershell %}
Start-Process $executable -WindowStyle Hidden
{% endhighlight %} 

Однако, обладая этими же правами, вы не можете найти и убить этот процесс по пути исполняемого файла. Следующая команда ничего не возвращает
{% highlight powershell %}
Get-Process | Where-Object {$_.Path-eq $executablePath} | Stop-Process 
{% endhighlight %} 

И даже зная его PID, нельзя его убить:
{% highlight powershell %}
Stop-Process -id $proccessId 
{% endhighlight %} 

Пародоксальная ситуация, когда служба может запусить процесс, но не может его убить. Мы уже хотели использовать docker для запуска тестовых сервисов, но решение было найдено.

Оказалось что можно найти этот процесс зная его PID:
{% highlight powershell %}
$process = Get-Process | Where-Object {$_.Id -eq $processId} 
{% endhighlight %} 

И если у процесса вызвать Kill() - то он запросто убивается:
{% highlight powershell %}
if ($process)
{
    $process.Kill()
}
{% endhighlight %} 

Таким образом, пришлось при запуске сервера сохранять его PID в папку с исполняемым файлом, чтобы при повторной сборке или при очистке можно было получить его, найти нужный процесс и убить его. 





